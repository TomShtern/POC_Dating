package com.dating.match.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;

/**
 * JWT Token Provider for validation (read-only)
 *
 * PURPOSE: Validate JWT tokens issued by user-service
 *
 * RESPONSIBILITIES:
 * - Parse JWT tokens from Authorization header
 * - Validate token signature
 * - Extract user ID from token claims
 * - Check token expiration
 *
 * WHY NOT GENERATE TOKENS:
 * - Match service only validates tokens (read-only)
 * - Tokens are generated by user-service (single source)
 * - Prevents token inconsistency across services
 *
 * SECURITY:
 * - Uses HMAC-SHA256 for signature verification
 * - Secret key must match user-service key
 * - Validates expiration date
 * - Handles malformed tokens gracefully
 *
 * JWT STRUCTURE:
 * - Header: Algorithm (HS256) and type (JWT)
 * - Payload: userId, email, expiration, etc.
 * - Signature: HMAC(header + payload, secret)
 *
 * ALTERNATIVES:
 * - OAuth2: More complex, overkill for internal services
 * - Session-based: Doesn't scale across services
 * - API keys: Less secure, no expiration
 *
 * RATIONALE:
 * - JWT is stateless (no session storage)
 * - Self-contained (all info in token)
 * - Standard format (RFC 7519)
 * - Works across microservices
 */
@Slf4j
@Component
public class JwtTokenProvider {

    @Value("${security.jwt.secret}")
    private String jwtSecret;

    @Value("${security.jwt.expiration-ms}")
    private long jwtExpirationMs;

    private SecretKey key;

    /**
     * Initialize signing key after bean construction
     */
    @PostConstruct
    public void init() {
        this.key = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
        log.info("JWT Token Provider initialized");
    }

    /**
     * Validate JWT token
     *
     * @param token JWT token string
     * @return true if token is valid
     */
    public boolean validateToken(String token) {
        try {
            Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token);
            return true;
        } catch (MalformedJwtException e) {
            log.error("Invalid JWT token: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            log.error("JWT token is expired: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            log.error("JWT token is unsupported: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            log.error("JWT claims string is empty: {}", e.getMessage());
        }
        return false;
    }

    /**
     * Extract user ID from JWT token
     *
     * @param token JWT token string
     * @return User ID from token subject
     */
    public Long getUserIdFromToken(String token) {
        Claims claims = Jwts.parser()
            .verifyWith(key)
            .build()
            .parseSignedClaims(token)
            .getPayload();

        return Long.parseLong(claims.getSubject());
    }

    /**
     * Extract email from JWT token
     *
     * @param token JWT token string
     * @return Email from token claims
     */
    public String getEmailFromToken(String token) {
        Claims claims = Jwts.parser()
            .verifyWith(key)
            .build()
            .parseSignedClaims(token)
            .getPayload();

        return claims.get("email", String.class);
    }

    /**
     * Extract bearer token from Authorization header
     *
     * @param authHeader Authorization header value
     * @return Token string without "Bearer " prefix
     */
    public String extractTokenFromHeader(String authHeader) {
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            return authHeader.substring(7);
        }
        return null;
    }
}
