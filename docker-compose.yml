# ============================================================================
# POC Dating - Docker Compose Configuration
# ============================================================================
#
# ⚠️  IMPORTANT: This file is for PRODUCTION DEPLOYMENT ONLY
#
# FOR LOCAL DEVELOPMENT:
#   You DO NOT need Docker! See backend/QUICKSTART.md instead.
#
#   Quick Start:
#   1. Install PostgreSQL locally
#   2. Run backend/setup-databases.sql
#   3. Start services with: mvn spring-boot:run
#   4. See backend/QUICKSTART.md for complete instructions
#
# ============================================================================
#
# PURPOSE: Production deployment with all services containerized
#
# WHY THIS FILE EXISTS:
# - Production deployment (all services in containers)
# - Full-stack testing (testing containerized deployment)
# - CI/CD pipeline (automated testing with containers)
# - Staging/demo environments
#
# WHY NOT USE FOR DEVELOPMENT:
# - Slower startup times vs native Java processes
# - Harder to debug (logs in containers)
# - More resource intensive
# - Extra complexity not needed for development
# - PostgreSQL on localhost is simpler and faster
#
# WHEN TO USE THIS FILE:
# ✅ Production deployment
# ✅ Staging environments
# ✅ Testing containerized deployment
# ✅ Demo environments
# ❌ Local development (use QUICKSTART.md instead)
#
# HOW TO USE (Production):
# 1. Build all services: cd backend && mvn clean install
# 2. Start containers: docker-compose up -d
# 3. Services will be available at:
#    - Vaadin UI: http://localhost:8090
#    - User Service: http://localhost:8081
#    - PostgreSQL: localhost:5432
#    - Redis: localhost:6379 (optional)
#    - RabbitMQ: localhost:5672 (optional, management UI: 15672)
#
# For development setup, see: backend/QUICKSTART.md
# For deployment details, see: docs/DEPLOYMENT.md
# ============================================================================

version: '3.8'

services:
  # PostgreSQL Database - Primary data store
  # WHY: ACID compliance essential for user data, matches, relationships
  postgres:
    image: postgres:15-alpine
    container_name: dating_postgres
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-dating_db}
      POSTGRES_USER: ${POSTGRES_USER:-dating_user}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-changeme123}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./db/init:/docker-entrypoint-initdb.d
    networks:
      - dating_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-dating_user}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Redis Cache - Session and real-time data cache
  # WHY: Fast in-memory cache for sessions, chat state, recommendations
  # RATIONALE: Dramatically improves performance vs DB queries
  redis:
    image: redis:7-alpine
    container_name: dating_redis
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    networks:
      - dating_network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # RabbitMQ Message Broker - Async event processing
  # WHY: Decouples services, enables event-driven architecture
  # RATIONALE: Allows services to communicate asynchronously
  # EVENTS: match-created, message-sent, user-profile-updated, etc.
  rabbitmq:
    image: rabbitmq:3.12-management-alpine
    container_name: dating_rabbitmq
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER:-guest}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD:-guest}
      RABBITMQ_DEFAULT_VHOST: ${RABBITMQ_VHOST:-/}
    ports:
      - "5672:5672"
      - "15672:15672"  # Management UI
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    networks:
      - dating_network
    healthcheck:
      test: rabbitmq-diagnostics -q ping
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # API Gateway Service - Single entry point
  # PURPOSE: Routes all API requests to appropriate microservice
  # PORT: 8080 (public-facing)
  # DEPENDENCIES: All downstream services
  api-gateway:
    build:
      context: ./backend/api-gateway
      dockerfile: Dockerfile
    container_name: dating_api_gateway
    ports:
      - "8080:8080"
    environment:
      SERVER_PORT: 8080
      USER_SERVICE_URL: http://user-service:8081
      MATCH_SERVICE_URL: http://match-service:8082
      CHAT_SERVICE_URL: http://chat-service:8083
      RECOMMENDATION_SERVICE_URL: http://recommendation-service:8084
      POSTGRES_HOST: ${POSTGRES_HOST:-postgres}
      POSTGRES_PORT: ${POSTGRES_PORT:-5432}
      REDIS_HOST: ${REDIS_HOST:-redis}
      RABBITMQ_HOST: ${RABBITMQ_HOST:-rabbitmq}
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    networks:
      - dating_network
    restart: unless-stopped

  # User Service - Authentication & Profiles
  # PURPOSE: Manages user registration, login, profiles, preferences
  # PORT: 8081 (internal only)
  user-service:
    build:
      context: ./backend/user-service
      dockerfile: Dockerfile
    container_name: dating_user_service
    ports:
      - "8081:8081"
    environment:
      SERVER_PORT: 8081
      SERVICE_NAME: user-service
      POSTGRES_HOST: ${POSTGRES_HOST:-postgres}
      POSTGRES_PORT: ${POSTGRES_PORT:-5432}
      REDIS_HOST: ${REDIS_HOST:-redis}
      RABBITMQ_HOST: ${RABBITMQ_HOST:-rabbitmq}
      JWT_SECRET: ${JWT_SECRET}
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    networks:
      - dating_network
    restart: unless-stopped

  # Match Service - Matching Algorithm
  # PURPOSE: Handles swipes, calculates matches, match notifications
  # PORT: 8082 (internal only)
  match-service:
    build:
      context: ./backend/match-service
      dockerfile: Dockerfile
    container_name: dating_match_service
    ports:
      - "8082:8082"
    environment:
      SERVER_PORT: 8082
      SERVICE_NAME: match-service
      POSTGRES_HOST: ${POSTGRES_HOST:-postgres}
      REDIS_HOST: ${REDIS_HOST:-redis}
      RABBITMQ_HOST: ${RABBITMQ_HOST:-rabbitmq}
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    networks:
      - dating_network
    restart: unless-stopped

  # Chat Service - Real-time Messaging
  # PURPOSE: WebSocket server for real-time chat, message history
  # PORT: 8083 (internal, accessed through gateway)
  # SPECIAL: Maintains WebSocket connections, integration with RabbitMQ for distribution
  chat-service:
    build:
      context: ./backend/chat-service
      dockerfile: Dockerfile
    container_name: dating_chat_service
    ports:
      - "8083:8083"
    environment:
      SERVER_PORT: 8083
      SERVICE_NAME: chat-service
      POSTGRES_HOST: ${POSTGRES_HOST:-postgres}
      REDIS_HOST: ${REDIS_HOST:-redis}
      RABBITMQ_HOST: ${RABBITMQ_HOST:-rabbitmq}
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    networks:
      - dating_network
    restart: unless-stopped

  # Recommendation Service - ML/Algorithm-based Recommendations
  # PURPOSE: Calculates personalized recommendations based on user preferences, matches, interactions
  # PORT: 8084 (internal only)
  # SPECIAL: Can be resource-intensive, independent scaling
  recommendation-service:
    build:
      context: ./backend/recommendation-service
      dockerfile: Dockerfile
    container_name: dating_recommendation_service
    ports:
      - "8084:8084"
    environment:
      SERVER_PORT: 8084
      SERVICE_NAME: recommendation-service
      POSTGRES_HOST: ${POSTGRES_HOST:-postgres}
      REDIS_HOST: ${REDIS_HOST:-redis}
      RABBITMQ_HOST: ${RABBITMQ_HOST:-rabbitmq}
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
    networks:
      - dating_network
    restart: unless-stopped

  # Vaadin UI Service - Pure Java Web Interface
  # PURPOSE: User-facing web application (100% Java using Vaadin)
  # PORT: 8090 (public-facing)
  # CHANGE: Replaced React/TypeScript with Vaadin for team Java expertise
  vaadin-ui:
    build:
      context: ./backend/vaadin-ui-service
      dockerfile: Dockerfile
    container_name: dating_vaadin_ui
    ports:
      - "8090:8090"
    environment:
      SERVER_PORT: 8090
      SERVICE_NAME: vaadin-ui-service
      USER_SERVICE_HOST: user-service
      MATCH_SERVICE_HOST: match-service
      CHAT_SERVICE_HOST: chat-service
      RECOMMENDATION_SERVICE_HOST: recommendation-service
      REDIS_HOST: redis
      JWT_SECRET: ${JWT_SECRET}
      LOG_LEVEL: ${LOG_LEVEL:-INFO}
    depends_on:
      user-service:
        condition: service_started
      match-service:
        condition: service_started
      chat-service:
        condition: service_started
      recommendation-service:
        condition: service_started
      redis:
        condition: service_healthy
    networks:
      - dating_network
    restart: unless-stopped

  # Frontend Application - React Web UI - ⚠️ DEPRECATED
  # STATUS: NOT USED - Replaced by Vaadin UI Service (Port 8090)
  # REASON: Team Java expertise, 3-week MVP timeline
  # SEE: docs/FRONTEND_OPTIONS_ANALYSIS.md for decision rationale
  # NOTE: Service commented out, kept for reference
  # frontend:
  #   build:
  #     context: ./frontend
  #     dockerfile: docker/Dockerfile
  #   container_name: dating_frontend_deprecated
  #   ports:
  #     - "3000:3000"
  #   environment:
  #     REACT_APP_API_URL: http://localhost:8080
  #     REACT_APP_WS_URL: ws://localhost:8080/ws
  #   depends_on:
  #     - api-gateway
  #   networks:
  #     - dating_network
  #   restart: unless-stopped

# Network Definition
# WHY: All containers on same network enables service discovery by name
networks:
  dating_network:
    driver: bridge

# Volume Definitions
# WHY: Persistent data storage across container restarts
volumes:
  postgres_data:
  redis_data:
  rabbitmq_data:
